#!/usr/bin/python
# -*- coding: utf8 -*-

# ADpassword - Cambio de clave en Active Directory
# author: Alfonso de Cala <alfonso.cala@juntadeandalucia.es>
# date: 17/Abr/2010


import ldap
from time import *

import pygtk
pygtk.require ('2.0')
import gtk
from subprocess import *
import os, os.path
from configobj import ConfigObj


class Gui:
  """
  Graphical interface
  """
  def __init__(self, basedir, user):
    """
    Show a dialog if user must change password. If not, just exit.
    """

    dic = {
       "on_window1_button_cancel_clicked" : (self.quit),
       "on_window1_button_ok_clicked" : (self.window1_button_ok_clicked),
       "on_window1_button_cancel_clicked" : (self.quit),
       "on_dialog1_button_yes_clicked" : (self.dialog1_button_yes_clicked),
       "on_dialog1_button_no_clicked" : (self.quit),
       "on_window1_main_destroy" : (self.quit), 
       "on_dialog1_main_destroy" : (self.quit), 
    }

    glade1 = gtk.Builder()

    glade1.add_from_file(basedir+"/ADpassword.ui")
    glade1.connect_signals(dic)

    self.window1=glade1.get_object("window1")
    self.dialog1=glade1.get_object("dialog1")

    self.dialog1_label=glade1.get_object("dialog1_label")
    self.window1_label_password1=glade1.get_object("window1_label_password1")
    self.window1_label_password2=glade1.get_object("window1_label_password2")

    self.user=user    


  def alert(self,message):
    dialog = gtk.MessageDialog(None, gtk.DIALOG_MODAL, gtk.MESSAGE_INFO, gtk.BUTTONS_CLOSE, message)
    dialog.run()
    dialog.destroy()
   
  def dialog1_button_yes_clicked(self,widget):
    self.dialog1.hide()
    self.window1.show()
    return
    
  def window1_button_ok_clicked(self,widget):
    newpassword1=self.window1_label_password1.get_text()
    newpassword2=self.window1_label_password2.get_text()
    if newpassword1 != newpassword2:
      self.alert("No coinciden las claves")
    else:
      self.user.changepassword(newpassword1)
      self.quit()
    return
 
  def run(self):
    if self.user.status == "ERROR":
      self.alert(self.user.message)
      return
    else:
      if self.user.mustchangepassword():
        message="Su clave caducará en %i días. ¿Desea cambiarla ahora?" % self.user.daysleft
        self.dialog1_label.set_text(message)
        self.dialog1.show()
      else:
        return
    gtk.main()

  def quit(*args):
      gtk.main_quit()


class ADuser():
  """
  Active Directory user
  """
  def __init__(self, server, base):
    """
    An Active Directory User
    """
    self.server=server
    self.base=base
    self.status="NO"
    self.message="No conectado"
    self.user=""
    self.password=""
    self.days=0
    self.warning=0

  def connect(self,user,password):

    self.user=user
    self.password=password

    ATTRIBUTES=("displayName","lastLogon","pwdLastSet")
    SCOPE = ldap.SCOPE_SUBTREE
    TIMEOUT=10
    FILTER="(&(name=%s)(!(objectclass=computer)))" % user
    
# Connect (bind) to ldap (Active Directory)
    try:
      l = ldap.initialize("ldap://"+self.server)
      dn="cn={0},{1}".format(user,self.base) 
      l.simple_bind_s(dn, self.password)
      self.status="OK"
      self.message="Conectado"
    except ldap.LDAPError, error_message:
      print "Error: %s " % error_message
      self.status="ERROR"
      self.message="Error de conexión"
      return

# Search for unique user data
    result = l.search_st(self.base, SCOPE, FILTER, ATTRIBUTES ,0 ,TIMEOUT)

    if len(result) == 1: 
      self.lastchange=result[0][1]['pwdLastSet'][0]
      self.status="OK"
      self.message="Datos disponibles"
    elif len(result) > 1:
      print "Error: too many results ",len(result)  
      self.status="ERROR"
      self.message="Demasiados datos coincidentes"
    else: 
      self.status="ERROR"
      self.message="Busqueda imposible"
    
    l.unbind_s()

    return
    
  def mustchangepassword(self):

    tstamp=self.nano2date(self.lastchange)
    self.daysfromlastchange=(time()-tstamp)/(60*60*24) 
#    today=strftime("%d-%m-%Y",localtime(time()))
#    formatedDate=strftime("%d-%m-%Y", ttupla)
    self.daysleft=self.days-self.daysfromlastchange
    
    print self.daysleft, self.warning
    if self.daysleft<self.warning or self.daysleft < 0:
      return True
    else:
      return False
    
  def changepassword(self,newpassword):
    
    args="-s -r %s -U %s " % (self.server,self.user)
    
#   print args
    
    p = Popen('/usr/bin/smbpasswd '+args, shell=True, bufsize=1024, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
    
    (out,err)=p.communicate(self.password+"\n"+newpassword+"\n"+newpassword+"\n")

    if p.wait() != 0:
      print "ERROR: al cambiar la clave"
    else:
      self.password=newpassword
    return 

  def nano2date(self,nanoseconds):
  
    seconds = long(nanoseconds) / 10000000
    ADToUnixConverter=((1970-1601) * 365.242190) * 86400
    unixtimestamp=seconds-ADToUnixConverter
    return unixtimestamp


# Main
def main():

  homedir = os.path.expanduser("~")
  basedir= os.path.dirname(__file__) 

  conf = ConfigObj(homedir+"/.ADpassword.conf")
  credentials = ConfigObj(homedir+"/.smbcredentials")

# Server: Windows Server with Active Directory
  server=conf["server"]

# searchbase: ldap format searchbase for user search
  base=conf["searchbase"]

  if "user" in credentials:
    user=credentials["username"]
    password=credentials["password"]
    use_credentials=True
    print "Using .smbpassword credentials"
  else:
    user=conf["username"]
    password=conf["password"]
    use_credentials=False
    print "Using .ADpassword credentials"
  
  aduser=ADuser(server,base)
  aduser.days=int(conf["days"])
  aduser.warning=int(conf["warning"])
  
  aduser.connect(user, password)

  app=Gui(basedir,aduser)

  if aduser.status=="OK":
    app.run()
    if password != aduser.password:
      conf['password'] = aduser.password
      if use_credentials:
        credentials.write()  
      else:
        conf.write()  
  else:
      app.alert(aduser.message)
      print "ERROR:",aduser.message
      

if __name__ == '__main__':
  main()

